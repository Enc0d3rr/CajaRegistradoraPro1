# ===== SEGURIDAD AVANZADA =====
import json
import hashlib
import hmac
import base64
import os
import uuid
import socket
import platform
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class SecurityManager:
    def __init__(self):
        # üîê CLAVE MAESTRA DERIVADA SEGURAMENTE
        self.master_key = self.derive_key("CAJA_REGISTRADORA_PRO_2024_SECRET_KEY_¬°NO_COMPARTIR!")
        self.fernet = Fernet(self.master_key)
    
    def derive_key(self, password: str) -> bytes:
        """Deriva una clave segura usando PBKDF2"""
        salt = b'caja_registradora_salt_2024_secure_v2'
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA512(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        return base64.urlsafe_b64encode(kdf.derive(password.encode()))
    
    def generar_hash_seguro(self, datos: dict) -> str:
        """Genera HMAC-SHA512 para m√°xima seguridad"""
        datos_ordenados = {k: datos[k] for k in sorted(datos.keys())}
        cadena = ''.join(str(v) for v in datos_ordenados.values())
        return hmac.new(self.master_key, cadena.encode(), hashlib.sha512).hexdigest()
    
    def encriptar_datos(self, datos: dict) -> str:
        """Encripta datos sensibles usando AES-256"""
        datos_str = json.dumps(datos, sort_keys=True)
        return self.fernet.encrypt(datos_str.encode()).decode()
    
    def desencriptar_datos(self, datos_encriptados: str) -> dict:
        """Desencripta datos verificando integridad"""
        try:
            datos_bytes = self.fernet.decrypt(datos_encriptados.encode())
            return json.loads(datos_bytes.decode())
        except Exception as e:
            raise ValueError(f"Error desencriptando datos: {e}")

class GeneradorLicencias:
    def __init__(self):
        # üîê SISTEMA DE SEGURIDAD AVANZADO
        self.security = SecurityManager()
        self.planes = {
            "perpetua": {"duracion": 36500, "precio": 2800, "nombre": "Licencia Perpetua"},
            "anual": {"duracion": 365, "precio": 1500, "nombre": "Suscripci√≥n Anual"}, 
            "empresarial": {"duracion": 36500, "precio": 6000, "nombre": "Plan Empresarial"}
        }

    def generar_licencia_avanzada(self, codigo_licencia, duracion_dias=30, id_cliente="", tipo="premium", equipo_id=None):
        """Genera una licencia v√°lida con seguridad avanzada"""
        try:
            # Usar equipo_id proporcionado o generar uno local
            if equipo_id is None:
                equipo_id = self.generar_id_instalacion_unico()
            
            licencia = {
                "codigo": codigo_licencia,
                "fecha_activacion": datetime.now().isoformat(),
                "duracion_dias": duracion_dias,
                "id_cliente": id_cliente or f"CLI_{datetime.now().strftime('%Y%m%d%H%M%S')}",
                "tipo": tipo,
                "version": "2.1",
                "fecha_generacion": datetime.now().isoformat(),
                "equipo_id": equipo_id
            }
            
            # üîê CAPA 1: Hash HMAC-SHA512
            licencia["hash_seguro"] = self.security.generar_hash_seguro(licencia)
            
            # üîê CAPA 2: Datos sensibles encriptados
            datos_sensibles = {
                'codigo': licencia['codigo'],
                'id_cliente': licencia['id_cliente'],
                'fecha_activacion': licencia['fecha_activacion'],
                'equipo_id': licencia['equipo_id']
            }
            licencia["datos_encriptados"] = self.security.encriptar_datos(datos_sensibles)
            
            # üîê CAPA 3: Checksum de integridad
            licencia["checksum"] = self.generar_checksum_integridad(licencia)
            
            print(f"‚úÖ Licencia generada para: {id_cliente}")
            print(f"üñ•Ô∏è  Equipo: {equipo_id}")
            print(f"üìÖ Duraci√≥n: {duracion_dias} d√≠as")
            return licencia
            
        except Exception as e:
            print(f"‚ùå Error generando licencia: {e}")
            return None
    
    def generar_id_instalacion_unico(self):
        """Genera ID √∫nico COMPATIBLE con el validador"""
        try:
            import socket
            import platform
            
            # BASE COMPATIBLE Y ESTABLE
            hostname = socket.gethostname().lower().strip()
            sistema = platform.system().lower()
            arquitectura = platform.machine().lower()
            
            id_base = f"{hostname}_{sistema}_{arquitectura}"
            return hashlib.sha3_512(id_base.encode()).hexdigest()[:32]
            
        except Exception as e:
            print(f"‚ùå Error generando ID: {e}")
            import socket
            fallback_base = f"fallback_{socket.gethostname()}"
            return hashlib.sha3_512(fallback_base.encode()).hexdigest()[:32]
    
    def generar_checksum_integridad(self, licencia):
        """Genera checksum para verificar integridad"""
        datos_integridad = {
            'codigo': licencia['codigo'],
            'hash_seguro': licencia['hash_seguro'],
            'fecha_generacion': licencia['fecha_generacion'],
            'version': licencia.get('version', '2.0')
        }
        datos_ordenados = {k: datos_integridad[k] for k in sorted(datos_integridad.keys())}
        cadena = ''.join(str(v) for v in datos_ordenados.values())
        return hashlib.sha3_512(cadena.encode()).hexdigest()
        
    def guardar_licencia(self, licencia, archivo_salida):
        """Guarda la licencia con rutas absolutas"""
        try:
            # Convertir a ruta absoluta
            if not os.path.isabs(archivo_salida):
                archivo_salida = os.path.abspath(archivo_salida)
            
            # Asegurar que el directorio existe
            directorio = os.path.dirname(archivo_salida)
            if directorio and not os.path.exists(directorio):
                os.makedirs(directorio, exist_ok=True)
            
            with open(archivo_salida, 'w', encoding='utf-8') as f:
                json.dump(licencia, f, indent=4, ensure_ascii=False)
            
            print(f"‚úÖ Licencia guardada en: {archivo_salida}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error guardando licencia: {e}")
            return False
    
    def generar_licencia_plan(self, codigo, plan, id_cliente="", equipo_id=None):
        """Genera licencia seg√∫n el plan contratado"""
        if plan not in self.planes:
            print(f"‚ùå Plan no v√°lido: {plan}")
            return None, None
        
        config = self.planes[plan]
        print(f"üéØ Generando {config['nombre']} - ${config['precio']} MXN")
        
        licencia = self.generar_licencia_avanzada(
            codigo, config['duracion'], id_cliente, plan, equipo_id
        )
        
        if not licencia:
            return None, None
        
        archivo_salida = f"licencia_{plan}_{id_cliente}_{datetime.now().strftime('%Y%m%d')}.json"
        
        if self.guardar_licencia(licencia, archivo_salida):
            return licencia, archivo_salida
        else:
            return licencia, None
    
    def generar_licencia_personalizada(self, codigo, duracion_dias, id_cliente="", equipo_id=None):
        """Genera licencia con duraci√≥n personalizada"""
        licencia = self.generar_licencia_avanzada(
            codigo, duracion_dias, id_cliente, "personalizada", equipo_id
        )
        
        if not licencia:
            return None, None
        
        archivo_salida = f"licencia_personalizada_{id_cliente}.json"
        
        if self.guardar_licencia(licencia, archivo_salida):
            return licencia, archivo_salida
        else:
            return licencia, None
    
    def mostrar_info_licencia(self, licencia):
        """Muestra informaci√≥n detallada de la licencia"""
        if not licencia:
            print("‚ùå Licencia inv√°lida")
            return
        
        fecha_activacion = datetime.fromisoformat(licencia['fecha_activacion'])
        fecha_expiracion = fecha_activacion + timedelta(days=licencia['duracion_dias'])
        dias_restantes = (fecha_expiracion - datetime.now()).days
        
        print(f"\nüìã INFORMACI√ìN DE LA LICENCIA")
        print("=" * 50)
        print(f"üîë C√≥digo: {licencia['codigo']}")
        print(f"üë§ Cliente: {licencia['id_cliente']}")
        print(f"üìÖ Fecha activaci√≥n: {fecha_activacion.strftime('%d/%m/%Y %H:%M')}")
        print(f"‚è∞ Duraci√≥n: {licencia['duracion_dias']} d√≠as")
        print(f"üìÖ Expira: {fecha_expiracion.strftime('%d/%m/%Y')}")
        print(f"üìä D√≠as restantes: {dias_restantes}")
        print(f"üéØ Tipo: {licencia['tipo']}")
        print(f"üÜî Equipo: {licencia.get('equipo_id', 'N/A')[:16]}...")
    
    def validar_licencia_avanzada(self, archivo_licencia):
        """Valida manualmente una licencia existente"""
        try:
            if not os.path.exists(archivo_licencia):
                print("‚ùå Archivo de licencia no encontrado")
                return False
            
            with open(archivo_licencia, 'r', encoding='utf-8') as f:
                licencia = json.load(f)
            
            # 1. Verificar checksum
            checksum_calculado = self.generar_checksum_integridad(licencia)
            if not hmac.compare_digest(licencia['checksum'], checksum_calculado):
                print("‚ùå Checksum inv√°lido")
                return False
            
            # 2. Verificar hash
            datos_verificacion = {k: v for k, v in licencia.items() 
                                if k not in ['hash_seguro', 'datos_encriptados', 'checksum']}
            
            hash_calculado = self.security.generar_hash_seguro(datos_verificacion)
            if not hmac.compare_digest(licencia['hash_seguro'], hash_calculado):
                print("‚ùå Hash de seguridad inv√°lido")
                return False
            
            # 3. Verificar datos encriptados
            try:
                datos_desencriptados = self.security.desencriptar_datos(licencia['datos_encriptados'])
                if (datos_desencriptados['codigo'] != licencia['codigo']):
                    print("‚ùå Datos encriptados no coinciden")
                    return False
            except Exception as e:
                print(f"‚ùå Error desencriptando: {e}")
                return False
            
            # 4. Verificar expiraci√≥n
            fecha_activacion = datetime.fromisoformat(licencia['fecha_activacion'])
            fecha_expiracion = fecha_activacion + timedelta(days=licencia['duracion_dias'])
            
            if datetime.now() > fecha_expiracion:
                print("‚ùå Licencia expirada")
                return False
            else:
                dias_restantes = (fecha_expiracion - datetime.now()).days
                print(f"‚úÖ Licencia v√°lida - {dias_restantes} d√≠as restantes")
                return True
                
        except Exception as e:
            print(f"‚ùå Error validando licencia: {e}")
            return False

# FUNCIONES PRINCIPALES
def generar_licencia_rapida():
    """Funci√≥n simple que genera y guarda licencia de prueba"""
    generador = GeneradorLicencias()
    
    codigo = "TEST-" + datetime.now().strftime("%H%M%S")
    id_cliente = "TEST"
    archivo = "licencia_test.json"
    
    print("‚ö° GENERANDO LICENCIA DE PRUEBA...")
    
    licencia, archivo_guardado = generador.generar_licencia_personalizada(
        codigo, 7, id_cliente
    )
    
    if licencia and archivo_guardado:
        print(f"üéâ ¬°√âXITO! Licencia guardada en: {archivo_guardado}")
        generador.mostrar_info_licencia(licencia)
    else:
        print("‚ùå Error generando la licencia")

def menu_principal():
    """Men√∫ principal del generador de licencias"""
    generador = GeneradorLicencias()
    
    while True:
        print("\n" + "="*60)
        print("üé´ GENERADOR DE LICENCIAS PROFESIONAL")
        print("="*60)
        print("1. üè∑Ô∏è  Generar licencia por PLAN")
        print("2. ‚öôÔ∏è  Generar licencia PERSONALIZADA") 
        print("3. üß™ Generar licencia de PRUEBA")
        print("4. üîç Validar licencia existente")
        print("5. üìä Mostrar planes disponibles")
        print("6. üö™ Salir")
        
        opcion = input("\nSeleccione opci√≥n: ").strip()
        
        if opcion == "1":
            print("\n" + "üè∑Ô∏è  GENERAR LICENCIA POR PLAN")
            print("-" * 30)
            print("Planes disponibles:")
            for plan_id, plan_info in generador.planes.items():
                print(f"   ‚Ä¢ {plan_id}: {plan_info['nombre']} - ${plan_info['precio']} MXN")
            
            plan = input("\nSeleccione plan (perpetua/anual/empresarial): ").strip().lower()
            if plan not in generador.planes:
                print("‚ùå Plan no v√°lido")
                continue
                
            codigo = input("C√≥digo de licencia: ").strip() or f"{plan.upper()}-{datetime.now().strftime('%Y%m%d')}"
            id_cliente = input("Nombre del cliente: ").strip() or "Cliente"
            equipo_id = input("Equipo ID del cliente [auto]: ").strip() or None
            
            licencia, archivo = generador.generar_licencia_plan(codigo, plan, id_cliente, equipo_id)
            if licencia and archivo:
                print(f"‚úÖ Licencia guardada en: {archivo}")
                generador.mostrar_info_licencia(licencia)
            else:
                print("‚ùå Error generando licencia")
                
        elif opcion == "2":
            print("\n" + "‚öôÔ∏è  LICENCIA PERSONALIZADA")
            codigo = input("C√≥digo: ").strip() or "CUSTOM-001"
            duracion = input("D√≠as de duraci√≥n: ").strip() or "30"
            id_cliente = input("Cliente: ").strip() or "ClientePersonalizado"
            equipo_id = input("Equipo ID [auto]: ").strip() or None
            
            try:
                licencia, archivo = generador.generar_licencia_personalizada(
                    codigo, int(duracion), id_cliente, equipo_id
                )
                if licencia and archivo:
                    print(f"‚úÖ Licencia guardada en: {archivo}")
                    generador.mostrar_info_licencia(licencia)
                else:
                    print("‚ùå Error generando licencia")
            except ValueError:
                print("‚ùå Los d√≠as deben ser un n√∫mero")
                
        elif opcion == "3":
            print("\n" + "üß™ GENERANDO LICENCIA DE PRUEBA...")
            generar_licencia_rapida()
            
        elif opcion == "4":
            archivo = input("Ruta del archivo de licencia: ").strip()
            if archivo:
                if os.path.exists(archivo):
                    generador.validar_licencia_avanzada(archivo)
                else:
                    print("‚ùå Archivo no encontrado")
                    
        elif opcion == "5":
            print("\n" + "üìä PLANES DISPONIBLES")
            print("-" * 40)
            for plan_id, plan_info in generador.planes.items():
                print(f"üéØ {plan_info['nombre']}:")
                print(f"   ‚Ä¢ Precio: ${plan_info['precio']} MXN")
                print(f"   ‚Ä¢ Duraci√≥n: {plan_info['duracion']} d√≠as")
                print(f"   ‚Ä¢ ID: {plan_id}")
                print()
                
        elif opcion == "6":
            print("üëã ¬°Hasta luego!")
            break
            
        else:
            print("‚ùå Opci√≥n inv√°lida")

if __name__ == "__main__":
    print("üîí GENERADOR DE LICENCIAS - SISTEMA PROFESIONAL")
    print("üíº Planes: Perpetua ($2,800) | Anual ($1,500) | Empresarial ($6,000)")
    menu_principal()